<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Free-Fly Camera Demo</title>
    <style>
      :root {
        color-scheme: dark;
      }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        overflow: hidden;
      }

      #overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(10, 12, 20, 0.85);
        color: #f0f6ff;
        text-align: center;
        flex-direction: column;
        gap: 1.5rem;
        padding: 2rem;
        transition: opacity 0.3s ease;
        z-index: 10;
      }

      #overlay.hidden {
        opacity: 0;
        pointer-events: none;
      }

      #overlay button {
        padding: 0.8rem 1.6rem;
        font-size: 1.1rem;
        background: linear-gradient(135deg, #4f9dff, #4377ff);
        border: none;
        border-radius: 999px;
        color: white;
        cursor: pointer;
        box-shadow: 0 10px 20px rgba(67, 119, 255, 0.3);
      }

      #overlay button:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(67, 119, 255, 0.4);
      }

      #overlay p {
        max-width: 32rem;
        line-height: 1.6;
        margin: 0;
      }

      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <h1>Free-Flying Camera</h1>
      <p>
        Click the button to capture the pointer and explore the scene. Use the mouse to
        look around, the <strong>WASD</strong> keys to move horizontally, and
        <strong>Q/E</strong> to descend or ascend. Hold <strong>Shift</strong> to accelerate.
      </p>
      <button type="button" id="startButton">Enter Simulation</button>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.1/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
      );
      camera.position.set(0, 5, 15);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const hemisphereLight = new THREE.HemisphereLight(0xd8eaff, 0x1f2a33, 0.6);
      scene.add(hemisphereLight);

      const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
      sunLight.position.set(50, 100, 0);
      sunLight.castShadow = true;
      scene.add(sunLight);

      const gridHelper = new THREE.GridHelper(400, 40, 0x5a6e7f, 0x32404d);
      scene.add(gridHelper);

      const groundGeometry = new THREE.PlaneGeometry(400, 400);
      const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x1b2835,
        roughness: 0.9,
        metalness: 0.1,
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x3fbf7f });
      const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8b5a2b });

      const treePositions = [
        [10, 0, -5],
        [-12, 0, 8],
        [6, 0, 20],
        [-18, 0, -15],
        [25, 0, 5],
        [-30, 0, 18],
      ];

      const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 4, 8);
      const leavesGeometry = new THREE.ConeGeometry(2.8, 6, 16);

      treePositions.forEach(([x, y, z]) => {
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.castShadow = true;
        trunk.receiveShadow = true;
        trunk.position.set(x, 2, z);
        scene.add(trunk);

        const leaves = new THREE.Mesh(leavesGeometry, treeMaterial);
        leaves.castShadow = true;
        leaves.receiveShadow = true;
        leaves.position.set(x, 6.5, z);
        scene.add(leaves);
      });

      const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x9ba8b8 });
      for (let i = 0; i < 40; i++) {
        const radius = 0.5 + Math.random() * 1.5;
        const rockGeometry = new THREE.DodecahedronGeometry(radius);
        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
        rock.position.set(
          (Math.random() - 0.5) * 200,
          radius / 2,
          (Math.random() - 0.5) * 200
        );
        rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
        rock.castShadow = true;
        rock.receiveShadow = true;
        scene.add(rock);
      }

      const controls = new PointerLockControls(camera, document.body);
      scene.add(controls.getObject());

      const overlay = document.getElementById("overlay");
      const startButton = document.getElementById("startButton");

      startButton.addEventListener("click", () => {
        controls.lock();
      });

      controls.addEventListener("lock", () => {
        overlay.classList.add("hidden");
      });

      controls.addEventListener("unlock", () => {
        overlay.classList.remove("hidden");
      });

      const keyState = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        up: false,
        down: false,
        boost: false,
      };

      const onKeyDown = (event) => {
        switch (event.code) {
          case "KeyW":
            keyState.forward = true;
            break;
          case "KeyS":
            keyState.backward = true;
            break;
          case "KeyA":
            keyState.left = true;
            break;
          case "KeyD":
            keyState.right = true;
            break;
          case "KeyQ":
            keyState.down = true;
            break;
          case "KeyE":
            keyState.up = true;
            break;
          case "ShiftLeft":
          case "ShiftRight":
            keyState.boost = true;
            break;
          default:
            break;
        }
      };

      const onKeyUp = (event) => {
        switch (event.code) {
          case "KeyW":
            keyState.forward = false;
            break;
          case "KeyS":
            keyState.backward = false;
            break;
          case "KeyA":
            keyState.left = false;
            break;
          case "KeyD":
            keyState.right = false;
            break;
          case "KeyQ":
            keyState.down = false;
            break;
          case "KeyE":
            keyState.up = false;
            break;
          case "ShiftLeft":
          case "ShiftRight":
            keyState.boost = false;
            break;
          default:
            break;
        }
      };

      document.addEventListener("keydown", onKeyDown);
      document.addEventListener("keyup", onKeyUp);

      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();
      const vertical = new THREE.Vector3();
      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();

        velocity.x -= velocity.x * 10.0 * delta;
        velocity.y -= velocity.y * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;

        direction.z = Number(keyState.forward) - Number(keyState.backward);
        direction.x = Number(keyState.right) - Number(keyState.left);
        direction.normalize();

        vertical.y = Number(keyState.up) - Number(keyState.down);

        const baseSpeed = keyState.boost ? 90 : 30;
        if (keyState.forward || keyState.backward) velocity.z -= direction.z * baseSpeed * delta;
        if (keyState.left || keyState.right) velocity.x -= direction.x * baseSpeed * delta;
        if (keyState.up || keyState.down) velocity.y += vertical.y * baseSpeed * delta;

        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);
        controls.getObject().position.y += velocity.y * delta;

        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
