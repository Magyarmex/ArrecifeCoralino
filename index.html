<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Free-Fly Camera Demo</title>
    <style>
      :root {
        color-scheme: dark;
      }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        overflow: hidden;
      }

      #overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(10, 12, 20, 0.85);
        color: #f0f6ff;
        text-align: center;
        flex-direction: column;
        gap: 1.5rem;
        padding: 2rem;
        transition: opacity 0.3s ease;
        z-index: 10;
      }

      #overlay.hidden {
        opacity: 0;
        pointer-events: none;
      }

      #overlay button {
        padding: 0.8rem 1.6rem;
        font-size: 1.1rem;
        background: linear-gradient(135deg, #4f9dff, #4377ff);
        border: none;
        border-radius: 999px;
        color: white;
        cursor: pointer;
        box-shadow: 0 10px 20px rgba(67, 119, 255, 0.3);
      }

      #overlay button:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(67, 119, 255, 0.4);
      }

      #overlay button:disabled {
        opacity: 0.6;
        cursor: wait;
        transform: none;
        box-shadow: none;
      }

      #overlay p {
        max-width: 32rem;
        line-height: 1.6;
        margin: 0;
      }

      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <h1>Free-Flying Camera</h1>
      <p id="statusMessage">
      <p>
        Click the button to capture the pointer and explore the scene. Use the mouse to
        look around, the <strong>WASD</strong> keys to move horizontally, and
        <strong>Q/E</strong> to descend or ascend. Hold <strong>Shift</strong> to accelerate.
      </p>
      <button type="button" id="startButton">Enter Simulation</button>
    </div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.160.1/build/three.module.js";
      import { PointerLockControls } from "https://unpkg.com/three@0.160.1/examples/jsm/controls/PointerLockControls.js";

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
      );
      camera.position.set(0, 5, 15);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const hemisphereLight = new THREE.HemisphereLight(0xd8eaff, 0x1f2a33, 0.6);
      scene.add(hemisphereLight);

      const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
      sunLight.position.set(50, 100, 0);
      sunLight.castShadow = true;
      scene.add(sunLight);

      const gridHelper = new THREE.GridHelper(400, 40, 0x5a6e7f, 0x32404d);
      scene.add(gridHelper);

      const groundGeometry = new THREE.PlaneGeometry(400, 400);
      const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x1b2835,
        roughness: 0.9,
        metalness: 0.1,
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      const baseplateMaterial = new THREE.MeshStandardMaterial({
        color: 0x262f3c,
        roughness: 0.6,
        metalness: 0.25,
      });
      const baseplate = new THREE.Mesh(
        new THREE.BoxGeometry(120, 2, 120),
        baseplateMaterial
      );
      baseplate.position.y = -0.99;
      baseplate.receiveShadow = true;
      baseplate.castShadow = true;
      scene.add(baseplate);

      const walkwayMaterial = new THREE.MeshStandardMaterial({
        color: 0x3a4a5f,
        roughness: 0.4,
        metalness: 0.2,
      });
      const trimMaterial = new THREE.MeshStandardMaterial({
        color: 0xd9e6ff,
        emissive: 0x1c7fff,
        emissiveIntensity: 0.3,
        roughness: 0.2,
        metalness: 0.5,
      });

      const walkwaySegments = [
        { size: [6, 0.3, 90], position: [0, 0.2, 0] },
        { size: [50, 0.3, 6], position: [0, 0.2, -30] },
        { size: [50, 0.3, 6], position: [0, 0.2, 30] },
        { size: [6, 0.3, 40], position: [30, 0.2, 15] },
        { size: [6, 0.3, 40], position: [-30, 0.2, 15] },
      ];

      walkwaySegments.forEach(({ size, position }) => {
        const segment = new THREE.Mesh(
          new THREE.BoxGeometry(...size),
          walkwayMaterial
        );
        segment.castShadow = true;
        segment.receiveShadow = true;
        segment.position.set(...position);
        scene.add(segment);
      });

      const hangarMaterial = new THREE.MeshStandardMaterial({
        color: 0x36465b,
        metalness: 0.45,
        roughness: 0.35,
      });
      const hangarRoofMaterial = new THREE.MeshStandardMaterial({
        color: 0x3f5169,
        metalness: 0.55,
        roughness: 0.25,
      });

      const hangarBase = new THREE.Mesh(
        new THREE.BoxGeometry(20, 6, 16),
        hangarMaterial
      );
      hangarBase.position.set(0, 3, -30);
      hangarBase.castShadow = true;
      hangarBase.receiveShadow = true;
      scene.add(hangarBase);

      const hangarRoof = new THREE.Mesh(
        new THREE.BoxGeometry(20.5, 2.4, 16.5),
        hangarRoofMaterial
      );
      hangarRoof.position.set(0, 8.4, -30);
      hangarRoof.castShadow = true;
      hangarRoof.receiveShadow = true;
      scene.add(hangarRoof);

      const hangarDoor = new THREE.Mesh(
        new THREE.BoxGeometry(10, 4.5, 0.5),
        trimMaterial
      );
      hangarDoor.position.set(0, 2.5, -21.8);
      hangarDoor.castShadow = true;
      scene.add(hangarDoor);

      const beaconMaterial = new THREE.MeshStandardMaterial({
        color: 0x1e2733,
        metalness: 0.6,
        roughness: 0.35,
      });
      const beaconGeometry = new THREE.CylinderGeometry(0.6, 0.6, 2.4, 12);

      const beaconPositions = [
        [-6, 1.2, -30],
        [6, 1.2, -30],
        [-6, 1.2, 30],
        [6, 1.2, 30],
        [0, 1.2, 10],
        [0, 1.2, -10],
        [30, 1.2, 5],
        [30, 1.2, 25],
        [-30, 1.2, 5],
        [-30, 1.2, 25],
      ];

      beaconPositions.forEach(([x, y, z]) => {
        const beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
        beacon.position.set(x, y, z);
        beacon.castShadow = true;
        beacon.receiveShadow = true;
        scene.add(beacon);

        const light = new THREE.PointLight(0x6fb9ff, 1.6, 25, 2.4);
        light.position.set(x, y + 1.2, z);
        scene.add(light);

        const cap = new THREE.Mesh(
          new THREE.CylinderGeometry(0.4, 0.5, 0.6, 12),
          trimMaterial
        );
        cap.position.set(x, y + 1.5, z);
        cap.castShadow = true;
        scene.add(cap);
      });

      const pad = new THREE.Mesh(
        new THREE.CylinderGeometry(12, 12, 0.6, 48),
        walkwayMaterial
      );
      pad.position.set(0, 0.3, 30);
      pad.receiveShadow = true;
      pad.castShadow = true;
      scene.add(pad);

      const padTrim = new THREE.Mesh(
        new THREE.RingGeometry(10.5, 11.5, 48),
        trimMaterial
      );
      padTrim.rotation.x = -Math.PI / 2;
      padTrim.position.set(0, 0.61, 30);
      scene.add(padTrim);

      const towerMaterial = new THREE.MeshStandardMaterial({
        color: 0x556d87,
        roughness: 0.35,
        metalness: 0.4,
      });
      const towerPositions = [
        [-40, -0.99, -40],
        [40, -0.99, -40],
        [40, -0.99, 40],
        [-40, -0.99, 40],
      ];

      towerPositions.forEach(([x, y, z]) => {
        const tower = new THREE.Mesh(
          new THREE.CylinderGeometry(2.8, 3.2, 18, 16),
          towerMaterial
        );
        tower.position.set(x, y + 9, z);
        tower.castShadow = true;
        tower.receiveShadow = true;
        scene.add(tower);

        const light = new THREE.PointLight(0x7fb4ff, 2.2, 35, 2);
        light.position.set(x, y + 20, z);
        light.castShadow = true;
        scene.add(light);
      });

      const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x3fbf7f });
      const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8b5a2b });

      const treePositions = [
        [10, 0, -5],
        [-12, 0, 8],
        [6, 0, 20],
        [-18, 0, -15],
        [25, 0, 5],
        [-30, 0, 18],
      ];

      const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 4, 8);
      const leavesGeometry = new THREE.ConeGeometry(2.8, 6, 16);

      treePositions.forEach(([x, y, z]) => {
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.castShadow = true;
        trunk.receiveShadow = true;
        trunk.position.set(x, 2, z);
        scene.add(trunk);

        const leaves = new THREE.Mesh(leavesGeometry, treeMaterial);
        leaves.castShadow = true;
        leaves.receiveShadow = true;
        leaves.position.set(x, 6.5, z);
        scene.add(leaves);
      });

      const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x9ba8b8 });
      const baseHalfSize = 60;
      for (let i = 0; i < 40; i++) {
        const radius = 0.5 + Math.random() * 1.5;
        const rockGeometry = new THREE.DodecahedronGeometry(radius);
        const rock = new THREE.Mesh(rockGeometry, rockMaterial);

        let x = 0;
        let z = 0;
        do {
          x = (Math.random() - 0.5) * 200;
          z = (Math.random() - 0.5) * 200;
        } while (Math.abs(x) < baseHalfSize && Math.abs(z) < baseHalfSize);

        rock.position.set(x, radius / 2, z);
        rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
        rock.castShadow = true;
        rock.receiveShadow = true;
        scene.add(rock);
      }

      const controls = new PointerLockControls(camera, document.body);
      scene.add(controls.getObject());

      const overlay = document.getElementById("overlay");
      const startButton = document.getElementById("startButton");
      const statusMessage = document.getElementById("statusMessage");

      startButton.addEventListener("click", () => {
        startButton.disabled = true;
        statusMessage.textContent = "Requesting pointer lockâ€¦ if it stalls, click the page once.";

      startButton.addEventListener("click", () => {
        controls.lock();
      });

      controls.addEventListener("lock", () => {
        startButton.disabled = false;
        overlay.classList.add("hidden");
        statusMessage.textContent =
          "Press Esc to release the pointer. Use WASD/QE + mouse to fly around.";
        overlay.classList.add("hidden");
      });

      controls.addEventListener("unlock", () => {
        overlay.classList.remove("hidden");
        statusMessage.textContent =
          "Pointer lock released. Click Enter Simulation to continue exploring.";
        startButton.focus();
      });

      document.addEventListener("pointerlockerror", () => {
        overlay.classList.remove("hidden");
        startButton.disabled = false;
        statusMessage.textContent =
          "Pointer lock was blocked by the browser. Click Enter Simulation again to retry.";
      });

      const keyState = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        up: false,
        down: false,
        boost: false,
      };

      const onKeyDown = (event) => {
        switch (event.code) {
          case "KeyW":
            keyState.forward = true;
            break;
          case "KeyS":
            keyState.backward = true;
            break;
          case "KeyA":
            keyState.left = true;
            break;
          case "KeyD":
            keyState.right = true;
            break;
          case "KeyQ":
            keyState.down = true;
            break;
          case "KeyE":
            keyState.up = true;
            break;
          case "ShiftLeft":
          case "ShiftRight":
            keyState.boost = true;
            break;
          default:
            break;
        }
      };

      const onKeyUp = (event) => {
        switch (event.code) {
          case "KeyW":
            keyState.forward = false;
            break;
          case "KeyS":
            keyState.backward = false;
            break;
          case "KeyA":
            keyState.left = false;
            break;
          case "KeyD":
            keyState.right = false;
            break;
          case "KeyQ":
            keyState.down = false;
            break;
          case "KeyE":
            keyState.up = false;
            break;
          case "ShiftLeft":
          case "ShiftRight":
            keyState.boost = false;
            break;
          default:
            break;
        }
      };

      document.addEventListener("keydown", onKeyDown);
      document.addEventListener("keyup", onKeyUp);

      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();
      const vertical = new THREE.Vector3();
      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();

        velocity.x -= velocity.x * 10.0 * delta;
        velocity.y -= velocity.y * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;

        direction.z = Number(keyState.forward) - Number(keyState.backward);
        direction.x = Number(keyState.right) - Number(keyState.left);
        direction.normalize();

        vertical.y = Number(keyState.up) - Number(keyState.down);

        const baseSpeed = keyState.boost ? 90 : 30;
        if (keyState.forward || keyState.backward) velocity.z -= direction.z * baseSpeed * delta;
        if (keyState.left || keyState.right) velocity.x -= direction.x * baseSpeed * delta;
        if (keyState.up || keyState.down) velocity.y += vertical.y * baseSpeed * delta;

        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);
        controls.getObject().position.y += velocity.y * delta;

        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
